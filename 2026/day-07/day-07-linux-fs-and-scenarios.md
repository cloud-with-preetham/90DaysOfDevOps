# Day 07 – Linux File System Hierarchy & Scenario-Based Practice

## Goal
Understand **where things live in Linux** and practice **real-world troubleshooting** using a DevOps mindset.

---

## Part 1: Linux File System Hierarchy

Linux follows a **hierarchical directory structure** starting from `/` (root). Every file, directory, and device exists somewhere under it.

---

### Core Directories

---

### `/` (root)
- The top-level directory; all other directories branch from here.
- The system cannot function without this directory.

**Observed (example):**
- `bin/`, `etc/`, `home/`, `var/`

**I would use this when…**
I want to understand the overall structure of the Linux system.

---

### `/home`
- Contains home directories for normal users.
- Each user gets a personal workspace here.

**Observed (example):**
- `/home/cwp`

**I would use this when…**
Managing user files, scripts, SSH keys, or user-specific configs.

---

### `/root`
- Home directory of the **root (admin) user**.
- Different from `/home/root`.

**Observed (example):**
- `.bashrc`
- `.ssh/`

**I would use this when…**
Working as root and storing admin-only scripts or configs.

---

### `/etc`
- Stores **system-wide configuration files**.
- Mostly text files, editable with an editor.

**Observed (example):**
- `/etc/hostname`
- `/etc/ssh/sshd_config`

**I would use this when…**
Configuring services, networking, users, or system behavior.

---

### `/var/log`
- Stores **log files** generated by the system and services.
- Extremely important for troubleshooting.

**Observed (example):**
- `/var/log/syslog`
- `/var/log/auth.log`

**I would use this when…**
Debugging application crashes, service failures, or login issues.

---

### `/tmp`
- Temporary files created by applications and users.
- Usually cleared automatically on reboot.

**Observed (example):**
- Temporary session files
- Installer temp data

**I would use this when…**
Testing scripts or storing short-lived files.

---

### `/bin`
- Essential command binaries needed for system boot.
- Commands available to all users.

**Observed (example):**
- `ls`
- `cp`
- `cat`

**I would use this when…**
Running basic Linux commands even in recovery mode.

---

### `/usr/bin`
- Most user-level commands and utilities live here.
- Larger than `/bin`.

**Observed (example):**
- `vim`
- `python`
- `git`

**I would use this when…**
Running installed tools and applications.

---

### `/opt`
- Optional or third-party software installations.
- Often used by vendors.

**Observed:**
- Nothing

**I would use this when…**
Installing or managing third-party applications.

---

### Hands-on Commands (Practiced)

```bash
# Find the largest log files
du -sh /var/log/* 2>/dev/null | sort -h | tail -5

# View hostname config
cat /etc/hostname

# Inspect home directory
ls -la ~

```

## Part 2: Scenario-Based Practice

The goal of this section is to practice **real-world troubleshooting** by thinking step by step.
Instead of memorizing commands, focus on **why** each command is used.

---

### Scenario 1: Service Not Starting

**Problem:**
A web application service called `myapp` failed to start after a server reboot.

---

**Step 1: Check service status**
```bash
systemctl status myapp
```
**Why:**
This shows whether the service is running, failed, or inactive, and gives initial error hints.

---

**Step 2: Check service logs***
```bash
journalctl -u myapp -n 50
```
**Why:**
Logs usually explain why the service failed (missing config, permission issue, port conflict, etc.).

---

**Step 3: Check if service is enabled on boot**
```bash
systemctl is-enabled myapp
```
**Why:**
To confirm whether the service is configured to start automatically after reboot.

---

**Step 4: Try restarting the service**
```bash
systemctl restart myapp
```
**Why:**
To see if the issue persists or was temporary.

**What I learned:**
Always follow this order: status → logs → enablement → restart.

---

### Scenario 2: High CPU Usage

**Problem:**
The application server is slow and suspected to have high CPU usage.

---

**Step 1: Check live CPU usage**
```bash
top
```
**Why:**
Displays real-time CPU consumption and running processes.

---

**Step 2: Identify top CPU-consuming processes**
```bash
ps aux --sort=-%cpu | head -10
```
**Why:**
Helps quickly identify which process is using the most CPU.

---

**Step 3: Note the PID**

- Record the Process ID (PID) of the suspicious process.

**Why:**
The PID is required for further investigation or action.

**What I learned:**
Never kill a process without identifying and understanding it first.

---

### Scenario 3: Finding Service Logs

**Problem:**
A developer asks where the logs for the docker service are located.
The service is managed by systemd.

---

**Step 1: Check service status**
```bash
systemctl status docker
```
**Why:**
Confirms service state and shows recent log messages.

---

**Step 2: View recent logs**
```bash
journalctl -u docker -n 50
```
**Why:**
Displays the latest log entries for the service.

---

**Step 3: Follow logs in real time**
```bash
journalctl -u docker -f
```
**Why:**
Useful during restarts or when actively debugging issues.

**What I learned:**
For systemd services, journalctl is the primary log source.

---

### Scenario 4: File Permissions Issue

**Problem:**
A script /home/user/backup.sh is not executing and returns Permission denied.

---

**Step 1: Check current permissions**
```bash
ls -l /home/user/backup.sh
```
**Look for:**
Missing x (execute) permission.

---

**Step 2: Add execute permission**
```
chmod +x /home/user/backup.sh
```
**Why:**
Scripts must have execute permission to run.

---

**Step 3: Verify permission change**
```bash
ls -l /home/user/backup.sh
```
**Expected:**
`-rwxr-xr-x`

---

**Step 4: Execute the script**
```bash
./backup.sh
```
**What I learned:**
Permission issues are a common cause of failures in automation and scripts.
